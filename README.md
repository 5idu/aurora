## golang 消息队列

### 发布订阅模式
- 消息分布在不同的 topic 里面
- 消息生产者将消息发送到 topic 里面
- 消息消费者从 topic 里消费消息，并返回 ack
- 生产者和消费者都无需感知对方的存在，即可完成消息传递
- 在许多发布/订阅系统中，发布者(producer)发布消息到一个中间的消息代理(broker)，然后订阅者(consumer)向该消息代理注册订阅，由消息代理来进行过滤。消息代理通常执行存储转发的功能将消息从发布者发送到订阅者
- broker 扮演消息存储和转发的角色


### 消息
- 消息格式
    - 消息数据大小限制 5M
- 消息压缩
    - LZ4
    - ZLIB
    - ZSTD
    - SNAPPY
- 批量发送
- 分块发送

### 生产者
- 同步发送消息到 broker
- 异步发送消息到 broker
    - 最大队列数
  

### 设计消息队列需要考虑的问题
- 高可用性（什么是高可用性？如何保证消息队列的高可用性？集群化，支持水平扩展）
- 消息数据可持久化（如何持久化？，没有持久化的情况下，消息溢出时，是阻塞知道队列可用还是直接丢弃部分数据）
- 数据一致性（应用解耦时产生的数据一致性问题，如何保障数据一致性（使用最终一致性方法解决））
- 多语言、多协议支持
- 易用性、拓展性（集群拓展？）、高可用性
- 异步处理、同步处理（request-reply的消息队列对消息被消耗之后有回复）
- 可维护性和容错性
- 数据的串行化协议，数据读写效率、缓冲区溢出、短消息的效率、大消息的效率、流媒体传输等
- 如何处理各种网络异常
- ...

### 关联的知识点
- 网络IO
- 磁盘IO
- 内存IO
```md
- 异步设计
- 缓存设计
- 锁的正确使用及可以使用硬件同步原语（CAS）替代锁获取更好性能
- 线程协调
- 序列化
- 内存管理
    - 在代码中尽量少的创建一次性对象
    - 创建对象池
    - Buffer Reset
- 消息批处理
- 使用顺序读写提升磁盘IO性能
- 利用 PageCache 加速消息读写
- ZeroCopy 零拷贝技术
```

异步发送如何保证严格顺序：
异步发送仍然可以保证严格顺序，但需要注意几点：
1. 发送方：需要单线程异步发送
2. 消费方：发送方需要记录一个递增流水号，保证每个发出的消息都有一个流水号，如果某个流水号的消息发送出错，需要重发这个流水号之后的所有消息。比如，连续异步发送12345这5条消息，假如已经异步发送了12345，然后异步检查发送结果的时候发现3发送失败了，需要从3开始重发。也就是按顺序重发345。
3. 消费逻辑需要幂等，能接受2中的这种情况，也就是说，收到的消息有可能是：12（3丢了）45 345。


### 消息队列中的角色
- 发送者发送消息到服务器
- 服务器接收到消息后，将消息发送给消费者，或持久化消息
- 消费者接收到消息后，处理消息

### 消息队列中的概念
- producer：发送者
- message：消息
- topic: 主题
- partition: 分区
- broker: 服务器
- consumer: 消费者
- consumer group: 消费者组